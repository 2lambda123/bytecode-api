using BytecodeApi.Extensions;
using System;

namespace BytecodeApi.Cryptography
{
	/// <summary>
	/// Class to encrypt and decrypt content using AES-256. Encrypted <see cref="byte" />[] objects generated by this class are proprietary and specific to this class only. For generic AES operations, see <see cref="Encryption" />.
	/// </summary>
	public static class ContentEncryption
	{
		private static readonly byte[] Magic = "BAPI_AES_1".ToAnsiBytes();

		/// <summary>
		/// Encrypts the specified <see cref="byte" />[] using the specified password and returns a <see cref="byte" />[] representing the encrypted version of <paramref name="data" />. The resulting binary is proprietary and can be decrypted using the <see cref="Decrypt" /> method.
		/// </summary>
		/// <param name="data">A <see cref="byte" />[] with the data to be encrypted.</param>
		/// <param name="password">A <see cref="string" /> representing the password to encrypt <paramref name="data" /> with. The password is hashed using SHA-256.</param>
		/// <returns>
		/// A new <see cref="byte" />[] representing the encrypted version of <paramref name="data" />. The resulting binary is proprietary and can be decrypted using the <see cref="Decrypt" /> method.
		/// </returns>
		public static byte[] Encrypt(byte[] data, string password)
		{
			return Encrypt(data, password, 1);
		}
		/// <summary>
		/// Encrypts the specified <see cref="byte" />[] using the specified password and returns a <see cref="byte" />[] representing the encrypted version of <paramref name="data" />. The resulting binary is proprietary and can be decrypted using the <see cref="Decrypt" /> method.
		/// </summary>
		/// <param name="data">A <see cref="byte" />[] with the data to be encrypted.</param>
		/// <param name="password">A <see cref="string" /> representing the password to encrypt <paramref name="data" /> with. The password is hashed using SHA-256.</param>
		/// <param name="passwordHashPasses">A <see cref="int" /> value indicating the number of hash passes for <paramref name="password" />.</param>
		/// <returns>
		/// A new <see cref="byte" />[] representing the encrypted version of <paramref name="data" />. The resulting binary is proprietary and can be decrypted using the <see cref="Decrypt" /> method.
		/// </returns>
		public static byte[] Encrypt(byte[] data, string password, int passwordHashPasses)
		{
			Check.ArgumentNull(data, nameof(data));
			Check.ArgumentNull(password, nameof(password));
			Check.ArgumentOutOfRangeEx.Greater0(passwordHashPasses, nameof(passwordHashPasses));

			byte[] iv = Encryption.GenerateIV();
			byte[] key = Hashes.ComputeBytes(password, HashType.SHA256, passwordHashPasses);
			byte[] keyHash = Hashes.ComputeBytes(key, HashType.SHA256, passwordHashPasses);
			return Magic.Concat(iv, BitConverter.GetBytes(passwordHashPasses), keyHash, Encryption.Encrypt(data, iv, key));
		}
		/// <summary>
		/// Decrypts the specified <see cref="byte" />[] using the specified password and returns a <see cref="byte" />[] representing the decrypted version of <paramref name="data" />. The <paramref name="data" /> parameter is a proprietary binary, created by the <see cref="Encrypt(byte[], string)" /> method.
		/// </summary>
		/// <param name="data">A <see cref="byte" />[] with the data to be decrypted.</param>
		/// <param name="password">A <see cref="string" /> representing the password to decrypt <paramref name="data" /> with.</param>
		/// <returns>
		/// A new <see cref="byte" />[] representing the decrypted version of <paramref name="data" />.
		/// </returns>
		public static byte[] Decrypt(byte[] data, string password)
		{
			Check.ArgumentNull(data, nameof(data));
			Check.ArgumentNull(password, nameof(password));
			Check.Format(data.Length >= Magic.Length && data.GetBytes(0, Magic.Length).Compare(Magic), "The " + nameof(data) + " parameter does not represent a valid " + nameof(ContentEncryption) + " binary.");

			byte[] iv = data.GetBytes(Magic.Length, 16);
			int passwordPasses = BitConverter.ToInt32(data, Magic.Length + 16);
			byte[] keyHash = data.GetBytes(Magic.Length + 20, 32);
			byte[] key = Hashes.ComputeBytes(password, HashType.SHA256, passwordPasses);
			byte[] userKeyHash = Hashes.ComputeBytes(key, HashType.SHA256, passwordPasses);

			int dataOffset = Magic.Length + 52;
			return userKeyHash.Compare(keyHash) ? Encryption.Decrypt(data.GetBytes(dataOffset, data.Length - dataOffset), iv, key) : throw Throw.WrongPassword();
		}
	}
}